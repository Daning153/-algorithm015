学习笔记
一、树
1.树的常用概念
根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度以及层数，树的高度。
2.概念解释
节点：树中的每个元素称为节点
父子关系：相邻两节点的连线，称为父子关系
根节点：没有父节点的节点
叶子节点：没有子节点的节点
父节点：指向子节点的节点
子节点：被父节点指向的节点
兄弟节点：具有相同父节点的多个节点称为兄弟节点关系
节点的高度：节点到叶子节点的最长路径所包含的边数
节点的深度：根节点到节点的路径所包含的边数
节点的层数：节点的深度+1（根节点的层数是1）
树的高度：等于根节点的高度
二、二叉树
1.概念
①什么是二叉树？
每个节点最多只有2个子节点的树，这两个节点分别是左子节点和右子节点。
②什么是满二叉树？
有一种二叉树，除了叶子节点外，每个节点都有左右两个子节点，这种二叉树叫做满二叉树。
③什么是完全二叉树？
有一种二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。
2.完全二叉树的存储
①链式存储
每个节点由3个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式比较常用，大部分二叉树代码都是通过这种方式实现的。
②顺序存储
用数组来存储，对于完全二叉树，如果节点X存储在数组中的下标为i，那么它的左子节点的存储下标为2*i，右子节点的下标为2*i+1，反过来，下标i/2位置存储的就是该节点的父节点。注意，根节点存储在下标为1的位置。完全二叉树用数组来存储时最省内存的方式。
3.二叉树的遍历
①前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
②中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的本身，最后打印它的右子树。
③后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印它本身。
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
时间复杂度：3种遍历方式中，每个节点最多会被访问2次，所以时间复杂度是O(n)。


一：如何理解“堆”
1，堆是一个完全二叉树；
完全二叉树要求除了最后一层，其他层的节点都是满的，最后一层的节点都靠左排列。
2，堆中每个节点都必须大于等于（或小于等于）其子树中每个节点的值。
堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。
3，对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，叫“小顶堆”。

二：如何实现“堆”
要实现一个堆，要先知道堆都支持哪些操作，已及如何存储一个堆。
1，如何存储一个堆：
完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。
2，往堆中插入一个元素
往堆中插入一个元素后，需要继续满足堆的两个特性
（1）如果把新插入的元素放到堆的最后，则不符合堆的特性了，于是需要进行调整，让其重新满足堆的特性，这个过程叫做 堆化（heapify）
（2）堆化实际上有两种，从下往上和从上往下
（3）从下往上的堆化方法：
堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。
 
3，删除堆顶元素
（1）从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，则堆顶元素存储的就是堆中数据的最大值或最小值。
（2）假设是大顶堆，堆堆顶元素就是最大的元素，但删除堆顶元素之后，就需要把第二大元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后在迭代地删除第二大节点，以此类推，直到叶子节点被删除。

但这种方式会使堆化出来的堆不满足完全二叉树的特性
（3）可以把最后一个节点放到堆顶，然后利用同样的父子节点对比方法，对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止，这是从上往下的堆化方法。
 
一个包含n个节点的完全二叉树，树的高度不会超过log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，即O(log n)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(log n)。

三：如何基于堆实现排序
（1）排序方法有时间复杂度是O(n^2)的冒泡排序，插入排序，选择排序，有时间复杂度是O（nlogn）的归并排序，快速排序，线性排序。

（2）借助堆这种数据结构实现的排序算法就叫作堆排序，这种排序方法的时间复杂度非常稳定，是O(nlogn)，并且它还是原地排序算法。
堆排序的过程大致分解为两大步骤：建堆和排序
（3）建堆：
1，首先将数组原地建成一个堆。“原地”：是指不借助另一个数组，就在原地数组上操作。
2，建堆有两种思路：
第一种：在堆中插入一个元素的思路。
尽管数组中包含n个数据，但是可以假设起初堆中只包含一个数据，就是下标为1的数据。然后，调用插入方法，将将下标从2到n的数据依次插入到堆中，这样就将包含n个数据的数组，组织成了堆
第二种：是从后往前处理数组，并且每个数据都是从上往下堆化。
第二种和第一种思路截然相反，第一种建堆思路的处理过程是从前往后处理数据，并且每个数据插入堆中时，都是从下往上堆化。
对下标从n/2开始到1的数据进行堆化，下标是n/2 + 1到n的节点，是叶子节点，不需堆化
3，建堆的时间复杂度
每个节点堆化的时间复杂度是O(logn)，则n/2+1个节点堆化的总时间复杂度是O(n)。
①：因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点高度k成正比。
（4）排序：
建堆结束后，数组中的数据已是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。
将它和最后一个元素交换，最大元素就放到了下标为n的位置
这个过程有点类似“删除堆顶元素”的操作，当堆顶元素移除后，把下标为n的元素放到堆顶，然后在通过堆化的方法，将剩下的n-1个元素重新构建成堆。堆化完成之后，在取堆顶元素，放到下标是n-1的位置，一直重复这个过程，直到最后堆中只剩下标为1的一个元素，排序工作就完成了。

（5）时间，空间复杂度，以及稳定性分析
①：整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。
②：堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是O(n)，排序过程的时间复杂度是O(nlogn),所以堆排序的时间复杂度是O(nlogn)
③：堆排序不是稳定的排序算法，可能改变值相等的数据原始相对顺序。